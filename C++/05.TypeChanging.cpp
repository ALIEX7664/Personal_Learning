////函数重载过程中的二义性和类型转换
//
//#include <iostream>
//
//using namespace std;
////1号函数
//void func(char ch){
//	cout << "#1" << endl;
//}
////2号函数，若该函数去掉，会出现编译错误，unc(s)、func(49)没有精确匹配的重载函数，
////将它们的类型都提升为 int 后仍然不能匹配，接下来进入自动类型转换阶段，
////发现 s 被转换为 char（整型转换）、long（整型转换）、double（整数和小数转换）后都有比较合适的函数，
////而且它们在同一个优先级中，谁也不比谁优秀，调用哪个都一样，产生了二义性，所以编译器会报错。
//void func(int n){
//	cout << "#2" << endl;
//}
////3号函数
//void func(long m){
//	cout << "#3" << endl;
//}
////4号函数
//void func(double f){
//	cout << "#4" << endl;
//}
//int main(){
//	short s = 99;
//	float f = 84.6;
//
//	func('a');  //不需要类型转换，调用func(char) 
//	func(s);  //将short转换成int，调用func(int)  此时short提升到int
//	func(49);  //不需要类型转换，调用func(int)
//	func(f);  //将float转换成double，调用func(double)
//	return 0;
//}
//
////C++ 标准规定，编译器应该按照从高到低的顺序来搜索重载函数，
////首先是精确匹配，然后是类型提升，最后才是类型转换；
////一旦在某个优先级中找到唯一的一个重载函数就匹配成功，不再继续往下搜索。
//
//
////如果在一个优先级中找到多个（两个以及以上）合适的重载函数，
////编译器就会陷入两难境地，不知道如何抉择，编译器会将这种模棱两可的函数调用视为一种错误，
////因为这些合适的重载函数同等“优秀”，没有一个脱颖而出，调用谁都一样。这就是函数重载过程中的二义性错误。
//
////注意，类型提升和类型转换不是一码事！类型提升是积极的，是为了更加高效地利用计算机硬件，不会导致数据丢失或精度降低；
////而类型转换是不得已而为之，不能保证数据的正确性，也不能保证应有的精度。
////类型提升只有上表中列出的几种情况，其他情况都是类型转换。